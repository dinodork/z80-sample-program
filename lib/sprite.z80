;
; Title:	ZX Spectrum 48K Sprite Routines
; Author:	Dean Belfield
; Created:	20/08/2011
; Last Updated:	02/07/2012
;
; Requires:	output.asm
;
; Modinfo:
;
; Subroutines Render_Sprites and Clear_Sprites now call Pixel_Address_Down for sake of readability
;

; This routine goes through the sprite logic table and runs the logic routine for each sprite
;

	include "sprite_data_block.z80"

Handle_Sprites:
	LD IX, Sprite_Data      ; The sprite data block
	LD B, Sprite_Max	; The number of sprites to handle
Handle_Sprites_1:
	LD A, (IX + Sprite_Logic + 1)	; Get the high address of the handler routine
	AND A						; If it is zero,
	JR Z, Handle_Sprites_3		; don't process the sprite
	LD HL, Handle_Sprites_2		; Set to the return address
	PUSH BC						; Push the loop counter
	PUSH IX						; Push the index register
	PUSH HL						; Push the return address (to simulate a call)
	LD H, A						; Set H to the previously fetched high address of handler routine
	LD L, (IX + Sprite_Logic)	; Fetch the low address of the handler routine
	LD A, (IX + Sprite_X)		; Store the current X and Y coordinates (for erase routine)
	LD (IX + Sprite_X_Old), A
	LD A, (IX + Sprite_Y)
	LD (IX + Sprite_Y_Old), A
	JP (HL)						; Jump to the handler. Return address is stacked, so RET from that routine
Handle_Sprites_2:
	POP IX	; This is the return address, so pop the index register
	POP BC	; Pop the loop counter
Handle_Sprites_3:
	LD DE, Sprite_Data_Block_Size	; Go to next sprite data block
	ADD IX, DE
	DJNZ Handle_Sprites_1			; Loop until all sprites have been processed
	RET

; This routine renders the sprites
; It's a bit of a work-in-progress but clears each sprite in turn before drawing it in the new position
; HL = Address of sprite definition table
Render_Sprites:
	; Self-modifying code ahead!
	; Instead of pushing and popping HL,
	; Store it as the operand inside the LD DE instruction.
	; The opcode is a single byte, hence we can write at the next byte.
	LD (Render_Sprites_SM1 + 1), HL
	LD IX, Sprite_Data
	LD B, Sprite_Max
Render_Sprites_Loop:
	PUSH BC
	LD B, (IX + Sprite_Y_Old)
	LD C, (IX + Sprite_X_Old)
	CALL Clear_Sprite
	LD B, (IX + Sprite_Y)
	LD C, (IX + Sprite_X)

Render_Sprites_SM1:
	LD DE, 0
	CALL Render_Sprite
	POP BC
Render_Sprites_2:
	LD DE, Sprite_Data_Block_Size
	ADD IX, DE
	DJNZ Render_Sprites_Loop
	RET

; This routine draws a single sprite; again, work in progress. No off-screen clipping or masking yet
; B = Y pixel position
; C = X pixel position
; DE = Address of sprite table (8 words; one word per pre-shifted sprite definition)
;
Render_Sprite:
	CALL Get_Pixel_Address
	PUSH HL			; Store screen address temporarily
	; We now have the bit offset (X bit coordinate % 8) in A,
	; this value stays constant throughout the rendering of this
	; sprite, so we optimize it by using self-modifying code.
	; The loop to rotate the bits is unrolled below, we jump to
	; the address after the last RRA - A, which will rotate the
	; bitmap A steps. The address to jump to is in the
	; JP Rotate_Into_Pixel_Position instruction, but we overwrite
	; the value from here.
	LD HL, After_Rotate_Into_Pixel_Position_SM
	LD C, A
	LD B, 0
	SUB HL, BC
	LD (Rotate_Into_Pixel_Position_SM + 1), HL

;;; Make a mask
;;; E.g. 1 => 01111111
;;;      2 => 00111111
;;;      ...
;;;      7 => 00000001
;;;
	LD HL, Make_mask_0
	ADD A, A
	LD C, A
	LD B, 0
	ADD HL, BC
	LD (Make_mask_SM1 + 1), HL
	LD A, 0
Make_mask_SM1:
	JP 0xDEAD
Make_mask_0:
	OR 0x80
	OR 0x40
	OR 0x20
	OR 0x10
	OR 0x08
	OR 0x04
	OR 0x02
	OR 0x01
After_Make_Mask:
Mask_Made:
	; The mask is done
	; Write it to the self-modifying code.
	; This will be used to clear bits that were wrapped in the rotations.
	LD (Clear_Rotated_Pixels_SM + 1), A
	; The inverse mask is used for transferring the wrapped bits to the octet
	; on the right.
	XOR 0xFF
	LD (Transfer_Bits_SM + 1), A

	LD H, 0			; Multiply pixel shift by 2
	LD L, 0 ;A
	ADD HL, HL		; I think this is quicker than shifting L and H
	ADD HL, DE		; Add base address of sprite table
	LD E, (HL)		; Get sprite definition address
	INC HL
	LD D,(HL)
	POP HL			; Get screen address back
	LD B, 16		; Height of sprite, in pixels

; Renders one pixel row of a sprite
; DE = Address of first byte of sprite row
; L = Offset from start of screen memory?
Render_Sprite_Row:
	PUSH BC
	LD B, 2         ; Sprite width in octets
Render_Sprite_Octet:
	LD A, (DE)		; Fetch sprite definition

Rotate_Into_Pixel_Position_SM:
	JP Write_Back	; Write_back replaced by actual jump address by modifying code, see above. It is
					; modified to After_Rotate_Into_Pixel_Position_SM - n where 0 <= n <= 7.					;
	RRCA
	RRCA
	RRCA
	RRCA
	RRCA
	RRCA
	RRCA

After_Rotate_Into_Pixel_Position_SM:
	LD C, A
Clear_Rotated_Pixels_SM:
	AND 0xFF

Write_Back:

	OR (HL)			; OR with contents of screen
	LD (HL), A		; Write back to screen
	INC DE			; Next byte of sprite definition
	INC L			; Next byte of screen memory

	LD A, C
Transfer_Bits_SM:
	AND 0x00
	LD (HL), A
	DJNZ Render_Sprite_Octet
	DEC L			; Go back to original screen address
	DEC L			; Go back to original screen address
	POP BC
	CALL Pixel_Address_Down
Render_Sprite_2:
	DJNZ Render_Sprite_Row
	RET

; Clear a single sprite
; B = Y pixel position
; C = X pixel position
;
Clear_Sprite:
	CALL Get_Pixel_Address	; This routine is in output.asm
	LD B, 16				; Height of sprite, in pixels
Clear_Sprite_1
	XOR A			; Clear A
	LD (HL), A		; Write 3 0's to line
	INC L
	LD (HL), A
	INC L
	LD (HL), A
	DEC L			; Go back to original screen address
	DEC L
	CALL Pixel_Address_Down
Clear_Sprite_2:
	DJNZ Clear_Sprite_1
	RET
